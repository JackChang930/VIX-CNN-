"""
Market Sentiment Model – Day 4
-----------------------------
Simple vectorised back‑tester for the BUY/SELL/HOLD signals generated by
`signal_generator.py`.

Assumptions (v0):
    • Capital:   USD 1.0 at start (normalised)
    • Instrument: SPY Adj Close (already in `signals.csv`)
    • Execution: Signals are generated **end‑of‑day (EOD)** and positions are
                 entered **at next day's close**; therefore the position
                 column is `signal.shift(1)`.
    • Position sizing: full‑notional long (+1), flat (0), or short (‑1) on SPY
    • Slippage/commission: 0 (can be parameterised later)

Outputs
-------
    1. Console summary of key metrics (CAGR, Sharpe, Max DD, etc.)
    2. `data/processed/equity_curve.csv` – running NAV series

CLI Usage
---------
    $ python src/backtester.py

© 2025 Your Name – MIT License
"""
from __future__ import annotations

import logging
import sys
from pathlib import Path
from typing import Final

import numpy as np
import pandas as pd

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------
PROJECT_ROOT: Final[Path] = Path(__file__).resolve().parent
PROCESSED_DIR: Final[Path] = PROJECT_ROOT / "data" / "processed"

SIGNALS_PATH: Final[Path] = PROCESSED_DIR / "signals.csv"
EQUITY_PATH: Final[Path] = PROCESSED_DIR / "equity_curve.csv"

TRADING_DAYS_PER_YEAR: Final[int] = 252

# 1. 增加交易成本參數
COMMISSION_RATE: Final[float] = 0.0  # 可以設定為 0.001 等
SLIPPAGE_RATE: Final[float] = 0.0    # 可以設定為 0.0005 等

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)],
)
logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Metric helpers
# ---------------------------------------------------------------------------

def max_drawdown(nav: pd.Series) -> float:
    cummax = nav.cummax()
    dd = (nav - cummax) / cummax
    return dd.min()


def sharpe_ratio(returns: pd.Series, rf: float = 0.0) -> float:
    returns = returns.dropna()  # 明確處理空值
    excess = returns - rf / TRADING_DAYS_PER_YEAR
    return np.sqrt(TRADING_DAYS_PER_YEAR) * excess.mean() / excess.std(ddof=1)  # 使用更保守的 ddof=1

# ---------------------------------------------------------------------------
# Back‑testing core
# ---------------------------------------------------------------------------

def backtest(df: pd.DataFrame, commission: float = COMMISSION_RATE, 
             slippage: float = SLIPPAGE_RATE) -> dict[str, float]:
    """Vectorised back‑test. Expects columns: spy_price, signal"""
    # Create daily pct‑change series (total return because we used Adj Close)
    df["spy_ret"] = df["spy_price"].pct_change().fillna(0.0)

    # Map signals ⇒ position weights
    signal_map = {"BUY": 1, "SELL": -1, "HOLD": 0}
    df["position"] = df["signal"].map(signal_map).fillna(0).shift(1)
    df["position"].iloc[0] = 0  # cannot trade before data starts

    # 計算交易成本
    trade_costs = df["position"].diff().abs() * (commission + slippage)
    df["strategy_ret"] = df["position"] * df["spy_ret"] - trade_costs
    df["nav"] = (1 + df["strategy_ret"]).cumprod()

    # Metrics
    total_return = df["nav"].iloc[-1] - 1
    days = (df.index[-1] - df.index[0]).days
    cagr = (df["nav"].iloc[-1]) ** (365.0 / days) - 1 if days else np.nan
    vol = df["strategy_ret"].std(ddof=0) * np.sqrt(TRADING_DAYS_PER_YEAR)
    sharpe = sharpe_ratio(df["strategy_ret"])
    mdd = max_drawdown(df["nav"])

    # Trade stats
    trades = (df["position"].diff().abs() > 0).sum()
    win_rate = (df.loc[df["strategy_ret"] != 0, "strategy_ret"] > 0).mean()

    metrics = {
        "CAGR": cagr,
        "Total Return": total_return,
        "Annualised Vol": vol,
        "Sharpe": sharpe,
        "Max Drawdown": mdd,
        "Trades": trades,
        "Win Rate": win_rate,
    }
    return metrics

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main() -> None:
    logger.info("Loading signals… %s", SIGNALS_PATH)
    df = pd.read_csv(SIGNALS_PATH, index_col="date", parse_dates=True)
    metrics = backtest(df)

    # Save NAV series
    df[["nav"]].to_csv(EQUITY_PATH, index_label="date")
    logger.info("Equity curve written → %s", EQUITY_PATH.relative_to(PROJECT_ROOT))

    # Pretty print metrics
    logger.info("\n==== Back‑test Summary ====")
    for k, v in metrics.items():
        if k in {"Trades"}:
            logger.info("%-15s : %d", k, v)
        else:
            logger.info("%-15s : %.2f%%", k, v * 100 if not np.isnan(v) else np.nan)


if __name__ == "__main__":
    main()
